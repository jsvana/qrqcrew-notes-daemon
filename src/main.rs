use anyhow::Result;
use clap::Parser;
use qrqcrew_notes_daemon::{
    Config, CsvFetcher, GitHubClient, HtmlFetcher, NotesGenerator, PendingFile,
};
use std::error::Error;
use std::path::PathBuf;
use std::time::Duration;
use tokio::net::TcpStream;
use tokio::time::sleep;
use tracing::{debug, error, info, warn};

#[derive(Parser)]
#[command(name = "qrqcrew-notes-daemon")]
#[command(about = "Generate Ham2K PoLo callsign notes from amateur radio organization rosters")]
struct Cli {
    /// Path to config file
    #[arg(short, long, default_value = "config.toml")]
    config: PathBuf,

    /// Run once and exit (override config)
    #[arg(long)]
    once: bool,

    /// Dry run - don't commit to GitHub
    #[arg(long)]
    dry_run: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive("qrqcrew_notes_daemon=info".parse()?),
        )
        .init();

    let cli = Cli::parse();
    let config = Config::load(Some(cli.config))?;

    let run_once = cli.once || config.daemon.run_once;

    let enabled_orgs: Vec<_> = config.organizations.iter().filter(|o| o.enabled).collect();

    if enabled_orgs.is_empty() {
        warn!("No organizations enabled in config");
        return Ok(());
    }

    info!(
        "Starting callsign notes daemon with {} enabled organization(s)",
        enabled_orgs.len()
    );

    loop {
        // Run connectivity diagnostics before each sync cycle
        run_connectivity_check().await;

        // Create GitHub client fresh each cycle to avoid stale connections
        let github = match GitHubClient::new(&config.github) {
            Ok(client) => Some(client),
            Err(e) => {
                error!("Failed to create GitHub client: {}", e);
                None
            }
        };

        let mut pending_files = Vec::new();

        for org in &enabled_orgs {
            info!("[{}] Starting sync", org.name);
            match prepare_org_update(org, cli.dry_run).await {
                Ok(Some(pending)) => {
                    info!(
                        "[{}] Prepared update for {} ({} members)",
                        org.name, pending.path, pending.member_count
                    );
                    pending_files.push(pending);
                }
                Ok(None) => {
                    info!("[{}] No update needed (dry run or empty roster)", org.name);
                }
                Err(e) => {
                    error!("[{}] Sync failed: {}", org.name, e);
                }
            }
        }

        // Batch commit all pending files
        if !pending_files.is_empty()
            && !cli.dry_run
            && let Some(ref github) = github
        {
            let message = build_commit_message(&pending_files);
            if let Err(e) = github.batch_commit(&pending_files, &message).await {
                error!("Batch commit failed: {:?}", e);
            }
        }

        if run_once {
            info!("Run-once mode, exiting");
            break;
        }

        info!("Sleeping for {} seconds", config.daemon.sync_interval_secs);
        sleep(Duration::from_secs(config.daemon.sync_interval_secs)).await;
    }

    Ok(())
}

fn build_commit_message(files: &[PendingFile]) -> String {
    if files.len() == 1 {
        let f = &files[0];
        format!(
            "Update {} callsign notes ({} members)\n\nGenerated by qrqcrew-notes-daemon",
            f.org_label, f.member_count
        )
    } else {
        let mut msg = String::from("Update callsign notes\n\n");
        for f in files {
            msg.push_str(&format!("- {}: {} members\n", f.org_label, f.member_count));
        }
        msg.push_str("\nGenerated by qrqcrew-notes-daemon");
        msg
    }
}

async fn prepare_org_update(
    org: &qrqcrew_notes_daemon::config::Organization,
    dry_run: bool,
) -> Result<Option<PendingFile>> {
    // 1. Fetch roster based on source type
    let members = match org.source_type.as_str() {
        "html_table" => {
            let callsign_idx = org.callsign_column_index.unwrap_or(1);
            let number_idx = org.number_column_index.unwrap_or(0);
            let fetcher = HtmlFetcher::new(org.roster_url.clone(), callsign_idx, number_idx);
            fetcher.fetch_members().await?
        }
        _ => {
            // Default to CSV
            let callsign_col = org
                .callsign_column
                .clone()
                .unwrap_or_else(|| "Callsign".to_string());
            let number_col = org
                .number_column
                .clone()
                .unwrap_or_else(|| "Number".to_string());
            let fetcher = CsvFetcher::new(
                org.roster_url.clone(),
                callsign_col,
                number_col,
                org.skip_rows,
            );
            fetcher.fetch_members().await?
        }
    };
    info!(
        "[{}] Fetched {} members from roster",
        org.name,
        members.len()
    );

    if members.is_empty() {
        warn!("[{}] No members found in roster, skipping", org.name);
        return Ok(None);
    }

    // 2. Generate notes file
    let generator = NotesGenerator::new(org.emoji.clone(), org.label.clone(), None);
    let content = generator.generate(&members);

    if dry_run {
        info!("[{}] Dry run - would generate:\n{}", org.name, content);
        return Ok(None);
    }

    // 3. Return pending file for batch commit
    Ok(Some(PendingFile {
        path: org.output_file.clone(),
        content,
        org_label: org.label.clone(),
        member_count: members.len(),
    }))
}

/// Run connectivity diagnostics to help debug network issues
async fn run_connectivity_check() {
    // Test targets: one from each service we use
    let targets = [
        ("Google (DNS)", "google.com:443"),
        ("Google Sheets", "docs.google.com:443"),
        ("GitHub API", "api.github.com:443"),
    ];

    info!("Running connectivity check...");

    for (name, addr) in targets {
        match tokio::time::timeout(Duration::from_secs(10), TcpStream::connect(addr)).await {
            Ok(Ok(_stream)) => {
                debug!("[connectivity] {} ({}) - OK", name, addr);
            }
            Ok(Err(e)) => {
                let mut error_msg = format!("{}", e);
                if let Some(source) = e.source() {
                    error_msg.push_str(&format!(" -> {}", source));
                }
                warn!("[connectivity] {} ({}) - FAILED: {}", name, addr, error_msg);
            }
            Err(_) => {
                warn!("[connectivity] {} ({}) - TIMEOUT after 10s", name, addr);
            }
        }
    }
}
