use anyhow::Result;
use clap::Parser;
use qrqcrew_notes_daemon::{Config, CsvFetcher, GitHubClient, NotesGenerator};
use std::path::PathBuf;
use std::time::Duration;
use tokio::time::sleep;
use tracing::{error, info, warn};

#[derive(Parser)]
#[command(name = "qrqcrew-notes-daemon")]
#[command(about = "Generate Ham2K PoLo callsign notes from amateur radio organization rosters")]
struct Cli {
    /// Path to config file
    #[arg(short, long, default_value = "config.toml")]
    config: PathBuf,

    /// Run once and exit (override config)
    #[arg(long)]
    once: bool,

    /// Dry run - don't commit to GitHub
    #[arg(long)]
    dry_run: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive("qrqcrew_notes_daemon=info".parse()?),
        )
        .init();

    let cli = Cli::parse();
    let config = Config::load(Some(cli.config))?;

    let run_once = cli.once || config.daemon.run_once;

    let enabled_orgs: Vec<_> = config
        .organizations
        .iter()
        .filter(|o| o.enabled)
        .collect();

    if enabled_orgs.is_empty() {
        warn!("No organizations enabled in config");
        return Ok(());
    }

    info!(
        "Starting callsign notes daemon with {} enabled organization(s)",
        enabled_orgs.len()
    );

    loop {
        for org in &enabled_orgs {
            info!("[{}] Starting sync", org.name);
            // Create per-org GitHub client with optional overrides
            let github = GitHubClient::with_overrides(&config.github, org.github.as_ref())?;
            if let Err(e) = sync_org(org, &github, cli.dry_run).await {
                error!("[{}] Sync failed: {}", org.name, e);
            }
        }

        if run_once {
            info!("Run-once mode, exiting");
            break;
        }

        info!("Sleeping for {} seconds", config.daemon.sync_interval_secs);
        sleep(Duration::from_secs(config.daemon.sync_interval_secs)).await;
    }

    Ok(())
}

async fn sync_org(
    org: &qrqcrew_notes_daemon::config::Organization,
    github: &GitHubClient,
    dry_run: bool,
) -> Result<()> {
    // 1. Fetch roster
    let fetcher = CsvFetcher::new(
        org.roster_url.clone(),
        org.callsign_column.clone(),
        org.number_column.clone(),
        org.skip_rows,
    );
    let members = fetcher.fetch_members().await?;
    info!("[{}] Fetched {} members from roster", org.name, members.len());

    if members.is_empty() {
        warn!("[{}] No members found in roster, skipping", org.name);
        return Ok(());
    }

    // 2. Generate notes file
    let generator = NotesGenerator::new(org.emoji.clone(), org.label.clone(), None);
    let content = generator.generate(&members);

    if dry_run {
        info!("[{}] Dry run - would generate:\n{}", org.name, content);
        return Ok(());
    }

    // 3. Check if changed and commit
    if !github.content_changed(&org.output_file, &content).await? {
        info!("[{}] No changes detected, skipping commit", org.name);
        return Ok(());
    }

    let commit_msg = format!(
        "Update {} callsign notes ({} members)\n\nGenerated by qrqcrew-notes-daemon",
        org.label, members.len()
    );

    github.commit_file(&org.output_file, &content, &commit_msg).await?;
    info!("[{}] Successfully committed to {}", org.name, org.output_file);

    Ok(())
}
