use anyhow::Result;
use clap::Parser;
use qrqcrew_notes_daemon::{
    Config, CsvFetcher, GitHubClient, HtmlFetcher, Member, NotesGenerator, PendingFile, QrzClient,
};
use std::collections::HashMap;
use std::error::Error;
use std::path::PathBuf;
use std::sync::Arc;
use std::time::Duration;
use tokio::net::TcpStream;
use tokio::sync::RwLock;
use tokio::time::sleep;
use tracing::{debug, error, info, warn};

#[derive(Parser)]
#[command(name = "qrqcrew-notes-daemon")]
#[command(about = "Generate Ham2K PoLo callsign notes from amateur radio organization rosters")]
struct Cli {
    /// Path to config file
    #[arg(short, long, default_value = "config.toml")]
    config: PathBuf,

    /// Run once and exit (override config)
    #[arg(long)]
    once: bool,

    /// Dry run - don't commit to GitHub
    #[arg(long)]
    dry_run: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::from_default_env()
                .add_directive("qrqcrew_notes_daemon=info".parse()?),
        )
        .init();

    let cli = Cli::parse();
    let config = Config::load(Some(cli.config))?;

    let run_once = cli.once || config.daemon.run_once;

    let enabled_orgs: Vec<_> = config.organizations.iter().filter(|o| o.enabled).collect();

    if enabled_orgs.is_empty() {
        warn!("No organizations enabled in config");
        return Ok(());
    }

    info!(
        "Starting callsign notes daemon with {} enabled organization(s)",
        enabled_orgs.len()
    );

    // Initialize QRZ client if configured
    let qrz_client = match &config.qrz {
        Some(qrz_config) if qrz_config.enabled => {
            info!("QRZ lookups enabled");
            Some(QrzClient::new(
                qrz_config.username.clone(),
                qrz_config.password.clone(),
            ))
        }
        Some(_) => {
            info!("QRZ lookups disabled in config");
            None
        }
        None => {
            info!("QRZ not configured, nicknames will not be fetched");
            None
        }
    };

    // Nickname cache persists across sync cycles
    let nickname_cache: Arc<RwLock<HashMap<String, Option<String>>>> =
        Arc::new(RwLock::new(HashMap::new()));

    loop {
        // Run connectivity diagnostics before each sync cycle
        run_connectivity_check().await;

        // Create GitHub client fresh each cycle to avoid stale connections
        let github = match GitHubClient::new(&config.github) {
            Ok(client) => Some(client),
            Err(e) => {
                error!("Failed to create GitHub client: {}", e);
                None
            }
        };

        let mut pending_files = Vec::new();

        for org in &enabled_orgs {
            info!("[{}] Starting sync", org.name);
            match prepare_org_update(org, cli.dry_run, &qrz_client, &nickname_cache).await {
                Ok(Some(pending)) => {
                    info!(
                        "[{}] Prepared update for {} ({} members)",
                        org.name, pending.path, pending.member_count
                    );
                    pending_files.push(pending);
                }
                Ok(None) => {
                    info!("[{}] No update needed (dry run or empty roster)", org.name);
                }
                Err(e) => {
                    error!("[{}] Sync failed: {}", org.name, e);
                }
            }
        }

        // Batch commit all pending files
        if !pending_files.is_empty()
            && !cli.dry_run
            && let Some(ref github) = github
        {
            let message = build_commit_message(&pending_files);
            if let Err(e) = github.batch_commit(&pending_files, &message).await {
                error!("Batch commit failed: {:?}", e);
            }
        }

        if run_once {
            info!("Run-once mode, exiting");
            break;
        }

        info!("Sleeping for {} seconds", config.daemon.sync_interval_secs);
        sleep(Duration::from_secs(config.daemon.sync_interval_secs)).await;
    }

    Ok(())
}

fn build_commit_message(files: &[PendingFile]) -> String {
    if files.len() == 1 {
        let f = &files[0];
        format!(
            "Update {} callsign notes ({} members)\n\nGenerated by qrqcrew-notes-daemon",
            f.org_label, f.member_count
        )
    } else {
        let mut msg = String::from("Update callsign notes\n\n");
        for f in files {
            msg.push_str(&format!("- {}: {} members\n", f.org_label, f.member_count));
        }
        msg.push_str("\nGenerated by qrqcrew-notes-daemon");
        msg
    }
}

async fn prepare_org_update(
    org: &qrqcrew_notes_daemon::config::Organization,
    dry_run: bool,
    qrz_client: &Option<QrzClient>,
    nickname_cache: &Arc<RwLock<HashMap<String, Option<String>>>>,
) -> Result<Option<PendingFile>> {
    // 1. Fetch roster based on source type
    let mut members = match org.source_type.as_str() {
        "html_table" => {
            let callsign_idx = org.callsign_column_index.unwrap_or(1);
            let number_idx = org.number_column_index.unwrap_or(0);
            let fetcher = HtmlFetcher::new(org.roster_url.clone(), callsign_idx, number_idx);
            fetcher.fetch_members().await?
        }
        _ => {
            // Default to CSV
            let callsign_col = org
                .callsign_column
                .clone()
                .unwrap_or_else(|| "Callsign".to_string());
            let number_col = org
                .number_column
                .clone()
                .unwrap_or_else(|| "Number".to_string());
            let fetcher = CsvFetcher::new(
                org.roster_url.clone(),
                callsign_col,
                number_col,
                org.skip_rows,
            );
            fetcher.fetch_members().await?
        }
    };
    info!(
        "[{}] Fetched {} members from roster",
        org.name,
        members.len()
    );

    if members.is_empty() {
        warn!("[{}] No members found in roster, skipping", org.name);
        return Ok(None);
    }

    // 2. Enrich with nicknames from QRZ if available
    if let Some(qrz) = qrz_client {
        enrich_with_nicknames(&mut members, qrz, nickname_cache, &org.name).await;
    }

    // 3. Generate notes file
    let generator = NotesGenerator::new(org.emoji.clone(), org.label.clone(), None);
    let content = generator.generate(&members);

    if dry_run {
        info!("[{}] Dry run - would generate:\n{}", org.name, content);
        return Ok(None);
    }

    // 4. Return pending file for batch commit
    Ok(Some(PendingFile {
        path: org.output_file.clone(),
        content,
        org_label: org.label.clone(),
        member_count: members.len(),
    }))
}

/// Enrich members with nicknames from QRZ lookups
async fn enrich_with_nicknames(
    members: &mut [Member],
    qrz: &QrzClient,
    cache: &Arc<RwLock<HashMap<String, Option<String>>>>,
    org_name: &str,
) {
    let mut cache_hits = 0;
    let mut lookups = 0;
    let mut found = 0;

    for member in members.iter_mut() {
        // Check cache first
        {
            let cache_read = cache.read().await;
            if let Some(cached) = cache_read.get(&member.callsign) {
                member.nickname = cached.clone();
                cache_hits += 1;
                if cached.is_some() {
                    found += 1;
                }
                continue;
            }
        }

        // Rate limit: 100ms between lookups (~10 req/sec)
        if lookups > 0 {
            sleep(Duration::from_millis(100)).await;
        }

        // Perform QRZ lookup
        lookups += 1;
        let nickname = match qrz.lookup_nickname(&member.callsign).await {
            Ok(name) => {
                if name.is_some() {
                    found += 1;
                    debug!("[{}] Found nickname for {}: {:?}", org_name, member.callsign, name);
                }
                name
            }
            Err(e) => {
                warn!(
                    "[{}] QRZ lookup failed for {}: {}",
                    org_name, member.callsign, e
                );
                None
            }
        };

        // Cache the result (including None to avoid repeated failures)
        {
            let mut cache_write = cache.write().await;
            cache_write.insert(member.callsign.clone(), nickname.clone());
        }

        member.nickname = nickname;
    }

    info!(
        "[{}] QRZ enrichment: {} cache hits, {} lookups, {} nicknames found",
        org_name, cache_hits, lookups, found
    );
}

/// Run connectivity diagnostics to help debug network issues
async fn run_connectivity_check() {
    // Test targets: one from each service we use
    let targets = [
        ("Google (DNS)", "google.com:443"),
        ("Google Sheets", "docs.google.com:443"),
        ("GitHub API", "api.github.com:443"),
    ];

    info!("Running connectivity check...");

    for (name, addr) in targets {
        match tokio::time::timeout(Duration::from_secs(10), TcpStream::connect(addr)).await {
            Ok(Ok(_stream)) => {
                debug!("[connectivity] {} ({}) - OK", name, addr);
            }
            Ok(Err(e)) => {
                let mut error_msg = format!("{}", e);
                if let Some(source) = e.source() {
                    error_msg.push_str(&format!(" -> {}", source));
                }
                warn!("[connectivity] {} ({}) - FAILED: {}", name, addr, error_msg);
            }
            Err(_) => {
                warn!("[connectivity] {} ({}) - TIMEOUT after 10s", name, addr);
            }
        }
    }
}
